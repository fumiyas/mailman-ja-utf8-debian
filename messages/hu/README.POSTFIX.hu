Mailman - The GNU Mailing List Management System
Copyright (C) 2001-2003 by the Free Software Foundation, Inc.
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA


ÁLTALÁNOS BEÁLLÍTÁSOK

    A Mailmannek minden gond nélkül mûködnie kell egy általánosan
    beállított Postfix-el. A dokumentáció írásakor a beállítások
    Postfix 19991231 verziótól kezdve pl13 verzióig, és 200010228
    verziótól pl08 verzióig, valamint Postfix 2.0.15-tel lettek 
    tesztelve.

    A Postfix alapértelmezésként speciális módon kezeli az -owner
    és -request címekre érkezõ leveleket. Ha azt szeretnénk, hogy
    az ide érkezõ leveleket is a Mailmannek továbbítsa a program
    kapcsoljuk ki ezt a funkciót a main.cf állomány módosításával:   
 
	  owner_request_specil = no
	
    Ahhoz hogy esetlegesen használni tudjuk a Mailman VERP küldési
    képességét ki kell kapcsolnunk az luser_relay (ez az alapértelmezett)
    beállítást és módosítanunk kell a recipient_delimeter értékén.
    Ehhez kommentezzük ki a main.cf állományban található összes
    luser_relay sort, visszatérve ezzel az alpértelmezett opcióhoz.
    Továbbá, helyezzük el main.cf fájlba a következõ sort:
    
          recipient_delimiter = +
	  
    A + jel használatával a a Defaults.py állományban megadott 
    alapértelmezett VERP_FORMAT és VERP_REGEXP értékek megfelelõen 
    fognak mûködni.

    A Postfix 450-es hibaüzenettel válaszol, ha egy nem létezõ lokális
    címre probálunk meg levelet továbbítani. Mivel ez nem jelent
    végzetes hibát, ezért a Mailman a kézbesítést addig ismételgeti,
    amíg le nem jár a DELIVERY_RETRY_PERIOD változóban megadott idõ
    (alapesetben 5 nap). Ennek elkerülésére be lehet állítani a
    Postfixet úgy, hogy a nem létezõ helyi felhasználóknak történõ
    kézbesítéskor a nem végzetes hibaüzenet helyet egy végzetes
    hiba üzenetet küldjön. Ehhez a beállításhoz a következõ sort kell
    elhelyezni a main.cf állományba:

          unknown_local_recipient_reject_code = 550

    Végül ha Postfix-stílusú virtuális tartományokat használunk, akkor
    olvassuk el az errõl szóló lejjebb található fejezetet.


POSTFIX ÉS MAILMAN ÖSSZEKAPCSOLÁSA

    A Postfixet össze lehet kapcsolni a Mailmannel úgy, hogy egy új
    lista létrehozásakor, vagy törlésekor a Postfix alias adatbázisa
    automatikusan frissüljön. Ehhez a következõk lépéseken kell 
    végigmennünk.

    A leírás feltételezi, hogy a Mailmant az alapértelmezett telepítési
    helyére telepítettük, ez a /usr/local/mailman. Ha nem így tettük,
    akkor a lépéseknél megfelelõen módosítsuk az elérési útvonalakat
    azokra amiket a konfigurálásakor a --prefix és --with-var-prefix
    kapcsolóknál használtunk.

    - Ha Postfix-stílusú virtuális tartományokat használunk és 
      szeretnénk, hogy a Mailman kezelje ezeket a tartományokat, akkor
      elõször olvassuk el a virtuális tartományokról lejjebb található
      fejezetet.

    - A $prefix/Mailman/mm_cfg.py állományban adjuk meg a következõt:

      MTA = 'Postfix'

      Az MTA változó értékével arra a programmodulra hivatkozunk a 
      Mailman/MTA könyvtárban, amelyik az adott MTA-ra jellemzõ hívások
      segítségével kezeli létrehozáskor vagy törléskor a listákat.

    - Keressük meg a Defaults.py állományban a POSTFIX_ALIAS_CMD és
      POSTFIX_MAP_CMD változókat. Gyõzõdjünk meg, hogy a változók a
      postalias és postmap programok helyes teljes elérési útvonalát
      tartalmazzák. Fontos, hogy ha ezeket megszeretnénk változtatni,
      akkor ne itt tegyük hanem az mm_cfg.py állományban.

    - Futtassuk a genaliases programot az aliases állomány létrehozásához:

      % cd /usr/local/mailman
      % bin/genaliases

      Gyõzõdjünk meg, hogy a data/aliases és data/aliases.db tulajdonosa
      a `mailman' és az állományok csoport tulajdonosa is a `mailman'.

      % su
      % chown mailman:mailman data/aliases*

    - Módosítsuk a Postfix main.cf konfigurációs állományában az alias_maps
      változót úgy, hogy a tartalmazza a következõ elérési útvonalat is:

          /usr/local/mailman/data/aliases

      (nincs a végén .db kiterjesztés) Az alias_database változóban ne
      adjuk meg ezt az útvonalat, mert nem szeretnénk hogy módosítsa a 
      Postfix newaliases parancsa a Mailman aliases.db állományát. Mindössze
      azt szeretnénk, hogy a Postfix figyelembe vegye az aliases.db 
      állományt, amikor a hely kézbesítési címeket keresi.

      Célszerû egy hash: típusú adatbázisként megadni ezt az állományt.
      Ezt megtehetjük például így:

      alias_maps = hash:/etc/postfix/aliases,
          hash:/usr/local/mailman/data/aliases

    - A Mailman konfigurálásakor használjuk a --with-mail-gid=mailman 
      kapcsolót (mellesleg ez az alapértelmezett beállítás), mivel az
      aliases.db állomány tulajdonosa a `mailman' felhasználó és a Postfix
      a Mailman wrapper programját mailman uid és gid alatt próbálja meg
      futtatni.

    Ennyi! Egy kis gond: amikor létrehozunk, vagy törlünk egy listát, akkor
    az aliases.db állomány azonnal frissül, viszont nem fut le automatikusan
    a változtatások érvényesítéséhez a "postfix reload" parancs. Ez azért
    van így, mert ehhez root jogokkal kell rendelkezni, vagy egy suid-root
    programnak kell futnia, amelyek biztonsági kockázatot jelentenek.
    A megoldás egyetlen hátrányát tehát az jelenti, hogy körülbelül csak
    egy perc múlva veszi észre a Postfix a módosításokat és érvényesít a
    változtatásokat. Ez a kis kényelmetlenség szerintünk elviselhetõ.


VIRTUÁLIS TARTOMÁNYOK

    A Postix 2.0 a támogatja "virtual alias domains" kezelést, amelyet
    a korábbi Postfix verziókban egyszerûen csak Postfix-típusú virtuális
    tartománykezelésnek hívtak. Ahhoz, hogy a Mailman képes legyen a 
    virtuális tartománykezelés használatához mind a Mailman, mind a 
    Postfix beállításokon változtatni kell. A Mailman alapesetben az
    összes virtuális tartományhoz tartaozó bejegyzést az 
    /usr/local/mailman/data/virtual-mailman állományban tárolja. A postmap
    program is ezen állomány alapján készíti el a virtual-mailman.db 
    állományt, melyet a Postfix valójában használni fog.

    Elõször a Postfix dokumentációban foglaltak alapján állítsuk be a 
    virtuális tartománykezelést (bõvebben a Postfix virtual(5) súgója ad
    eligazítást). Fontos, hogy el ne felejtsük megadni, ahogy a súgóban
    le van írva a "virtual-alias.domain anything" sort, mivel a Mailman
    virtual-mailman állománya nem tartalmazza ezt a sort. Javasoljuk,
    hogy még mielõtt telepítenénk a Mailmant, gyõzödjünk meg róla, hogy
    megfelelõen mûködik a virtuális tartománykezelés.

    A következõ lépséként a Postfix virtual_maps változóhoz kell egy 
    újabb könyvtár elérési utat adni:

    virtual_maps = <your normal virtual files>,
        hash:/usr/local/mailman/data/virtual-mailman

    Esetünkben a Mailman az alapértelmezett telepítési könyvtárban
    helyezkedik el. Régebbi Postfix-eknél nincsen virtual_alias_maps
    változó, ez esetben használjuk a virtual_maps változót.

    Következõ lépésként az mm_cfg.py állományba állítsuk be a
    POSTFIX_STYLE_VIRTUAL_DOMAINS változóba azon virtuális tartományokat,
    amelyekre a Mailmannek figyelnie kell. Elõfordulhat, hogy nem itt nem
    soroljuk fel a Postfix beállításunk által támogatott összes virtuális
    tartományunkat. Az itt megadott értékeknek pontosan egyezniük kell a
    levelezõlisták host_name változójában megadott értékekkel.

    Nézzük meg egy példán keresztül:

    Tegyük fel, hogy a Postfixben a dom1.ain, dom2.ain és dom3.ain
    virtuális tartományokat szeretnénk kezelni. Ehhez mondjuk a main.cf
    állományban a következõ beállítások vannak megadva:

        myhostname = mail.dom1.ain
        mydomain = dom1.ain
        mydestination = $myhostname, localhost.$mydomain
        virtual_maps = 
	    hash:/some/path/to/virtual-dom1,
            hash:/some/path/to/virtual-dom2,
            hash:/some/path/to/virtual-dom2

    Példánkban a virtual-dom1 állományban a következõ sorokat adtuk meg:

        dom1.ain  IGNORE
        @dom1.ain @mail.dom1.ain

    Ezzel a Postfixet arra utasítottuk, hogy minden dom1.ain-re címzett
    levelet tegyen ugyanabba a postafiókba, mint a mail.dom1.ain, az
    alapértelmezett címre érkezõket.

    Ez esetben a POSTFIX_STYLE_VIRTUAL_DOMAINS-ben nem szabad megadnunk 
    a dom1.ain-t, mivel különben a Mailman levelezõlisták bejegyzései a
    dom1.ain tartományban a következõ lennének

        mylist@dom1.ain         mylist
        mylist-request@dom1.ain mylist-request
        # és így tovább ...

    Az egyre pontosabb bejegyzések felülírják az elõttük található
    általánosabb bejegyzéseket, ezzel megakadályozzák a dom1.ain
    levelezõlisták megfelelõ mûködését.

    Azonban az mm_cfg.py állományban megadjuk a dom2.ain és dom3.ain
    értékeket:
    
        POSTFIX_STYLE_VIRTUAL_DOMAINS = ['dom2.ain', 'dom3.ain']

    Ezzel elértük, hogy minden olyan listának, amelyet a Mailman a fenti
    két tartomány valamelyikében hoz létre a megfelelõ bejegyzései a
    /usr/local/mailman/data/virtual-mailman állományban helyesen fognak
    megjelenni.

    Csak úgy mint a fent említett data/aliases* állományoknál, itt is
    gyõzõdjünk meg arról, hogy a data/virtual-mailman és 
    data/virtual-mailman.db állományok felhasználó- és csoporttulajdonosa
    `mailman' legyen. A megfelelõ mûködéshez tehát elõbb hozzuk létre
    a virtuális tartományokat, futtassuk a bin/genaliases programot és
    végül ellenõrizzük ezen állományokon a jogosultságokat. Ezen túl,
    többet már nem kell velük foglalkoznunk.


EGY MÁSIK MEGKÖZELÍTÉS

    Fil <fil@rezo.net> máshogy, virtual maps és szabványos keresési
    kifejezések használatával kezeli a virtuális tartományokat.
    Leírása megtalálható:

    (franciául)  http://listes.rezo.net/comment.php
    (angolul) http://listes.rezo.net/how.php

    Egy jó (és egyszerûbb) módszer azon esetekben ha nem bánjuk, hogy
    a tartomány részben egy újabb hostnév jelenik, ezzel növelve annak
    a címnek a karakter hosszát, amelyen keresztül a felhasználók
    elérik a listát. Pl. a listát a felhasználók sajatlista@lists.dom.ain
    címmel érik el sajatlista@dom.ain cím helyett.

    Ezt a megoldást a dokumentáció készítõje alaposan nem tesztelte.



Local Variables:
mode: text
indent-tabs-mode: nil
End:

\documentclass{howto}

\title{GNU Mailman - インストールマニュアル}
\author{Barry Warsaw}
\authoraddress{\email{barry(at)python.org}}

\date{\today}
\release{2.1}                   % software release, not documentation
\setreleaseinfo{}               % empty for final release
\setshortversion{2.1}           % major.minor only for software

\begin{document}

\maketitle

% This makes the Abstract go on a separate page in the HTML version;
% if a copyright notice is used, it should go immediately after this.
%
\ifhtml
\chapter*{序\label{front}}
\fi

\begin{abstract}
\noindent
この文書は GNU Mailman を POSIX システム (例: \UNIX{}, MacOSX, GNU/Linux)
にインストールする方法を説明するものです. 基本的なインストール手順
だけでなく, あなたが使用するウェブとメールサーバに統合するための
ガイドラインを含んでいます\footnote{
訳注：現時点で翻訳は訳者（菊地・池田）の環境において確認できる部分
に限られています.
}.



\noindent
GNU Mailman のウェブサイトは \url{http://www.list.org} です.
\end{abstract}

% The ugly "%begin{latexonly}" pseudo-environment supresses the table
% of contents for HTML generation.
%
%begin{latexonly}
\tableofcontents
%end{latexonly}


\section{インストールの必要事項}

GNU Mailman は \UNIX{} や MacOSX, GNU/Linux といった POSIX に基くシステム
のほとんどで稼動します. 現在のところ Windows では動きません. あなたが
メールを送信できるメールサーバを必要とし, CGI/1.1 API を備えたウェブ
サーバが必要です. ウェブサーバには
\ulink{Apache}{http://httpd.apache.org} が, ぴったりです. メールサーバには
例えば,
\ulink{Postfix}{http://www.postfix.org},
\ulink{Exim}{http://www.exim.org},
\ulink{Sendmail}{http://www.sendmail.org}, 
\ulink{qmail}{http://cr.yp.to/qmail.html} 
などはどれも使えます.

Mailman をソースからインストールするには, セキュリティ向上のために
用いられている ラップ\footnote{訳註: wrapper ... ○○ラップ(商品名)と同じ
「包む」という意味なので, こう訳してみました}
プログラムを構築するときに, ANSI C コンパイラーが
必要です. \ulink{GNU C コンパイラ gcc}{http://gcc.gnu.org} の 2.8.1 以降の
バージョンでうまくいきます.

システムには \ulink{Python}{http://www.python.org} インタプリタが
どこかにインストールされていなければなりません.
Mailman 2.1 には Python 2.1 またはそれよりも新しいものが必要です.
Python 2.3 以上を推奨します.

\section{システムセットアップ}

Mailman ソフトウェアのインストールの前に，特定のユーザとグループを
追加登録することでシステムの準備をする必要があります.
このため, この節のステップを実行するには root になる必要があります.

\subsection{グループとユーザの追加}

Mailman は, ファイルを所有し, プロセスを走らせるために, 他で使用されていない
ユーザとグループの名前を必要とします. Mailman の基本的なセキュリティは
グループ所有権の許可(パーミッション)に基いています. 従って, このステップを
きちんとしておくことが重要です\footnote{インストールが完了してから
パーミッションをチェックして修正することができます.}. 典型的には,
\code{mailman} という名前のユーザとグループを作成することになります.
\code{mailman} ユーザは \code{mailman} グループのメンバーでなければ
なりません. Mailman は \code{mailman} ユーザとグループの下に,
set-group-id (setgid) ビットを立ててインストールされます.

もし, この名前が既に使われていたなら, 別のユーザとグループ名を選ぶことが
できますが, \program{configure} を走らせるときに覚えておかないといけません.
もし, 別のユーザ名を選んだなら, これを \program{configure} の
\longprogramopt{with-username} オプションで指定します. また, 別の
グループ名を選んだ場合には, \program{configure} の 
\longprogramopt{with-username} オプションで指定してください.

Linux システムでは, 次のコマンドでこれらのアカウントを作成することが
できます. ご利用のシステムのマニュアルで詳細を確認してください:

\begin{verbatim}
    % groupadd mailman
    % useradd -c''GNU Mailman'' -s /no/shell -d /no/home -g mailman mailman
\end{verbatim}

\subsection{インストールディレクトリの作成\label{create-install-dir}}
通常, Mailman は単一のディレクトリにインストールされ, そこには
Mailman ソースコードと, 実行時のデータ(リストと保存書庫)の両方が入ります.
静的なプログラムファイルと変化するデータファイルを分離して, 別のディレクトリ
に入れることも可能です. ここではこのことに関するオプションを説明します.

Mailman のデフォルトのインストールディレクトリは
\file{/usr/local/mailman}\footnote{これは Mailman 2.1 のデフォルトです.
以前のバージョンでは, /home/mailman に全てインストールしていました.}
このインストールディレクトリ(\var{\$prefix} で参照します) を変更するには
configure で \longprogramopt{prefix} オプションを使います.
以前のバージョンから更新するには, インストールディレクトリを変更す
るので無い限り, \longprogramopt{prefix} を設定する必要があります.

\begin{notice}[warning]
Mailman を \code{nosuid} オプションでマウントされたファイルシステムに
インストールすることはできません. これがあると Mailman のインストールに
失敗します. というのは, セキュリティ上の理由で setgid プログラムの利用を
前提としているからです. もし, これがあてはまるようでしたら, 単純に,
setgid プログラムを許している場所に Maiman をインストールしてください.
\end{notice}

インストールのディレクトリが \code{mailman} グループに設定されて
いることを確認してください (あるいは \longprogramopt{with-groupname} で指定
しようとしているグループ). そして, setgid ビットがセットされ
ていることを確認してください\footnote{もし, BSD システムを使うなら
\ref{bsd-issues} も読んでください} また, このディレクトリが全ての
ユーザに読み取りと実行(移動)可能であることを保証したいと思う
でしょう. 以下のシェルコマンドでこれらのことが設定できます:

\begin{verbatim}
    % cd $prefix
    % chgrp mailman .
    % chmod a+rx,g+ws .
\end{verbatim}

これで, Mailman ソフトウェアを configure しインストールする
準備ができました.

\section{Mailman の構築とインストール\label{building}}

\subsection{\program{configure} を実行}

Mailman をインストールする前に \program{configure} を実行して, システム
で必要になるいろいろなインストールオプションを設定しなければなりません.

\begin{notice}[note]
下にある，\longprogramopt{with-mail-gid} と \longprogramopt{with-cgi-gid}
のオプションに特に注意. 多分これが必要になります.
\end{notice}

この節に書いてある手順を実行する間は, あなたは root に
なるべきではあり \strong{ません}. 自分自身のログイン名か, 他のソフトを
インストールするときに使うアカウントを使ってください. また,
\code{mailman} ユーザになる必要はありませんが, そうしても構いません.
但し, 前の手順で作成した \var{\$prefix} ディレクトリの書き込み許可を
得るためには, そのアカウントが \code{mailman} グループに所属している
必要があります.
ターゲットのインストールディレクトリに書き込み権限があることと,
そこに setgid ファイルを作成できることを確認してください.
(NFS や他のマウント方式で setgid を禁止している場合があります)

もし, 他の GNU ソフトをインストールしたことがあるなら, \program{configure}
スクリプトにはおなじみでしょう. Mailman の tarball を開いた
ディレクトリに \program{cd} して, \program{configure} を引数を付けずに実行して
ください:

\begin{verbatim}
  % cd mailman-<version>
  % ./configure
  % make install
\end{verbatim}

以下のオプションで Mailman のインストールをカスタマイズできます.

\begin{description}
\item[\longprogramopt{prefix}=\var{dir}]
    標準的な GNU configure のオプションで Mailman がインス
    トールされることになるベースのディレクトリを変更します．
    デフォルトでは \var{\$prefix} は \file{/usr/local/mailman} です．この
    ディレクトリはその時点で存在していなければならず, 
    \ref{create-install-dir} で説明したようにセットアップされていなけれ
    ばなりません．

\item[\longprogramopt{exec-prefix}=\var{dir}]
    標準的な GNU configure のオプションでアーキテクチャに
    依存したバイナリのインストールディレクトリを指定できます．

\item[\longprogramopt{with-var-prefix}=\var{dir}]
    交換可能なデータを \var{\$prefix} や \var{\$exec-prefix} の代わりに
    \var{dir} の下に保存します. このようなデータの例としては,
    リストの保存書庫やリスト設定データベースがあります.

\item[\longprogramopt{with-python}=\file{/path/to/python}]
    ラッププログラムで使用する Python インタプリタを変更
    して指定することができます．デフォルトはシェルの \var{\$PATH}
    の中で最初に見つかったものを使います.

\item[\longprogramopt{with-username}=\var{username-or-uid}]
    \code{mailman} でないユーザ名を使う場合に指定する.
    このオプションの値には整数のユーザID またはユーザ名を使うことができます.
    \var{\$prefix} ディレクトリがこのユーザの所有であることを確認してください.

\item[\longprogramopt{with-groupname}=\var{groupname-or-gid}]
    \code{mailman} でないグループ名を使う場合に指定する.
    このオプションの値には整数のグループID またはグループ名を使うことができます.
    \var{\$prefix} ディレクトリがこのグループの所有であることを確認してください.

\item[\longprogramopt{with-mail-gid}=\var{group-or-groups}]
    メールラップ を介してスクリプトを実行する際のグループを
    指定します．\var{group-or-groups} は，１個または複数の整数
    のグループID でも，グループの名前であっても可です．リス
    トの最初の値で実際に存在 するグループの値が使用されます．
    デフォルトでは，これは \code{mailman} \code{other} \code{mail}
    \code{daemon} のリストになっています.

    \begin{notice}[note]
    これは高度にシステム依存であり，正しい値を知っておく必
    要があります．というのは，グループ ID が メールラップ プロ
    グラムにコンパイルされてセキュリティを高めるからです．
    \program{Sendmail} を使っているシステムでは, \file{sendmail.cf} に 
    \var{DefaultUser} を使って \program{sendmail} プロセスの gid が 設定
    されています．(もし，コメントアウトされていたら，それで
    もデフォルトを示しているかもしれません)
    \end{notice}

    このスイッチの正しい値を知るために, 使用しているメールサーバの
    説明や設定ファイルをチェックしてください.

\item[\longprogramopt{with-cgi-gid}=\var{group-or-groups}]
    CGI ラップ を介してスクリプトを実行する際のグループを
    指定します. \var{group-or-groups} は, 1個または複数の整数
    のグループID でも，グループの名前であっても可です．リス
    トの最初の値で実際に存在 するグループの値が使用されます．
    デフォルトでは，これは \code{www} \code{www-data} \code{nobody} の リスト
    になっています．

    \begin{notice}[note]
    この値は Web サーバの設定に依存します．正しい値を知っ
    ておく必要があります． というのは，グループIDがCGI ラップ
    プログラムにコンパイルされてセキュリティを高めるからで
    す．これが違っていると Mailman CGI スクリプトは 動きま
    せん．
    \end{notice}

    もし Apache を使っていれば，\file{httpd.conf} に書かれている 
    \var{Group} オプション の値をチェックしてください．

\item[\longprogramopt{with-cgi-ext}=\var{extension}]
    cgi プログラムの拡張子を指定します. \file{\var{\$prefix}/cgi-bin} に
    置かれた CGI ラップ はこの拡張子を持ちます．(ウェブサーバ
    によっては 拡張子が必要です) \var{extension} には区切りの . (dot) 
    を入れておくこと．

\item[\longprogramopt{with-mailhost}=\var{hostname}]
    メールが出て行く時のホスト名(FQDN)を指定します. インストール
    が完了すれば, この値は \file{\var{\$prefix}/Mailman/mm_cfg.py} で上書き
    することができます.

\item[\longprogramopt{with-urlhost}=\var{hostname}]
    ウェブ URL のホスト名 (FQDN) を指定します. インストールが
    完了すれば, この値は \file{\var{\$prefix}/Mailman/mm_cfg.py} で上書き
    することができます.

\item[\longprogramopt{with-gcc}=no]
    gcc が見つかっても使いません．\program{cc} が \var{\$PATH} に無いとい
    けません．

\end{description}

\subsection{Make とインストール}

\program{configure} を実行したら, \program{make} を走らせ, 次に
\program{make install} とすることで, Mailman を構築しインストールする
ことができます.

\section{インストールのチェック}

\program{make install} を実行した後, 正しいパーミッションとグループ
所有権が設定されていることを \program{check_perms} スクリプトで
確かめてください. まずインストールディレクトリ(\var{\$prefix})に移動します.
そして, \program{bin/check_perms} プログラムを実行します. 
ソースディレクトリで \program{bin/check_perms} を実行しようとしないでく
ださい. インストールディレクトリでのみ実行可能です.

これが問題を報告しなければ, あなたのインストールは正しく設定さ
れていた可能性が高い <ウィンク> です. もし, 問題点が報告されたら,
手で修正するか, もう一度インストールをやりなおすか, \program{check_perms}
を使って(多分, 一番簡単)修正することが出来ます.

\begin{itemize}
\item インストールを行ったユーザ (\var{\$prefix} のファイルの所有権を持つ
      ユーザ) になるか, root になります.

\item \program{bin/check_perms -f} を実行します.

\item エラーの報告がなくなるまで, 上の手順を繰り返す!
\end{itemize}

\section{ウェブサーバの設定}

おめでとう！Mailman ソフトウェアのインストールが完了しました． 
しかし，実際に全てをうまく動かすには，Mailman を ウェブサーバと
メールシステムの 両方に接続しないといけません．

もし，メールとウェブサーバを別のマシンで動かして，Mailman を NFS 
経由で 共有したいと考えていたら，その２つのマシンの時計が同期
していることを 確かめてください．この手の環境では，
\file{Mailman/LockFile.py} に定義された \var{CLOCK_SLOP} という定数を使って，
時計のずれを補償したファイルロック機構 にすることができます．

この節では Mailman のウェブインタフェースをウェブサーバに接続するために
必要な事柄を説明します. ここでの手順は Apache ウェブサーバに若干偏って
いますので, 詳細についてはご利用のウェブサーバの説明書を参照してください.

ウェブサーバの設定で \file{\var{\$prefix}/cgi-bin} に CGI スクリプトの
実行許可を与えてください. 書き加える行は以下のようなものになる
はずです. (もちろん, \var{\$prefix} のところは実際の絶対パスに
してください.)

\begin{verbatim}
    Exec        /mailman/*      $prefix/cgi-bin/*
\end{verbatim}
% $ - emacs turd

  又は:

\begin{verbatim}
    ScriptAlias /mailman/       $prefix/cgi-bin/
\end{verbatim}
% $ - emacs turd

\begin{notice}[warning]
CGIスクリプトを実行する ユーザIDが \code{mailman} グループに入って
\strong{いない}ことをよく確認してください．でないと，非公開の保存書庫
が誰にでも見られてしまいます.
\end{notice}

Mailman, Python, GNU のロゴをWebサーバのアクセス可能なところに
コピーしてください．例えば Apacheの場合，画像ファイルを入れて
おくのに \file{icons} ディレクトリが用意されているはずです．例:

\begin{verbatim}
    % cp $prefix/icons/*.{jpg,png} /path/to/apache/icons
\end{verbatim}

\file{\var{\$prefix}/Mailman/mm_cfg.py} にロゴのベースディレクトリを書いた
行を追加してください．例えば:

\begin{verbatim}
  IMAGE_LOGOS = '/images/'
\end{verbatim}

\var{IMAGE_LOGOS} のデフォルト値は \file{/icons/} です. 
\file{Defaults.py.in} に書かれたコメントを読んでください.

Pipermail の公開メーリングリスト保存書庫を参照できるように 
Web サーバを 設定してください. 例えば Apache の場合:

\begin{verbatim}
    Alias   /pipermail/     $varprefix/archives/public/
\end{verbatim}
% $ - emacs turd

ここで, \var{\$varprefix} は通常は \var{\$prefix} と同じで,
\longprogramopt{with-var-prefix} オプションを付けて \program{configure}
した場合にはその値となります. また,
このディレクトリでシンボリックリンクをたどることができるように 
ウェブサーバを設定してください．でないと，Pipermail の書庫にアク
セスできません. Apache のユーザは \var{FollowSymLinks} オプションを 
調べてください.

また, もし公開保存書庫を国際化したいのであれば, Pipermail
ディレクトリのデフォルト文字集合の指示をオフにした方がよいかも
しれません. でないと, 多言語の保存書庫は正しく見ることができな
いでしょう. Apache の標準のインストールについての設定例は:

\begin{verbatim}
    <Directory "/usr/local/mailman/archives/public/">
        AddDefaultCharset Off
    </Directory>
\end{verbatim}

ここで, ウェブサーバを再起動してください.

\section{メールサーバの設定\label{mail-server}}

この節では Mailman のメールインタフェースをメールサーバに
接続するのに必要な事柄を説明します. ここでの手順はメールサーバによって
異なりますが; もしあなたのメールサーバが次の小節に見当たらない
場合は, ここにある文書から一般化することを試してください. そして, 文書の更新を
Mailman 開発者にプレゼントすることも考えてください.

\subsection{Postfix メールサーバを使う場合}

Mailman は標準の Postfix インストールとうまく合うようになっています.
Postfix 2.1.5 (を含む) までの各種バージョンで試験済みです.

デフォルトでは, Postfix は \code{-owner} と \code{-request} のアドレスを
特殊扱いします. このようなメールも Mailman に届けてもらうために, 
次のように \file{main.cf} に追加してこのオプションをオフにします:

\begin{verbatim}
    owner_request_special = no
\end{verbatim}

Mailman のオプションである VERP 配送をサポートするためには, 
\code{luser_relay} を無効(これが既定値)にしたままで, 
\code{recipient_delimiter} を
設定して 拡張アドレス\footnote{訳注：原文は extended address 
semantics なので, `拡張されたアドレスの意味論'. 実際には,
extended address とだけ書いてある文献が多いようなので, `意味論'
を省略した.}
を有効にします.
\file{main.cf} の \code{luser_relay} の値をどれもコメントアウトし,
デフォルトのままにします. また, 次のように \file{main.cf} ファイルに
追加します.

\begin{verbatim}
    recipient_delimiter = +
\end{verbatim}

区切り記号として \samp{+} を使うと \file{Defaults.py} にある
\var{VERP_FORMAT} と \var{VERP_REGEXP} のデフォルト値とうまく合います.

存在しないローカルアドレスにメールを送信しようとすると, Postfix は
450 のエラーコードを返すかもしれません. これは一時的なエラーを表す
コードなので, Mailman はデフォルトで \var{DELIVERY_RETRY_PERIOD} -- 5
日間メールを送信しようとし続けます. 次のように \file{main.cf} に
設定することで, 存在しないローカルユーザについて恒久的なエラーコード
を返させることができます.

\begin{verbatim}
    unknown_local_recipient_reject_code = 550
\end{verbatim}

最後に, もし Postfix スタイルの仮想ドメインを使っているなら,
下の仮想ドメインサポートの節を読んでください.

\subsubsection{Postfix と Mailman の統合}

Postfix と Mailman を統合すると, 新しいリストを作成したり,
リストを削除したときに, Postfix のエイリアスデータベースが自動的に
更新されるようになります. これを実現するための手順は以下のとおりです.

以下の説明では, Mailman がデフォルトの位置, つまり \file{/usr/local/mailman}
にインストールされているものと仮定します. もし, そうでなければ,
\program{configure} で用いた \longprogramopt{prefix} と
\longprogramopt{with-var-prefix} のオプションに従って読み替えてください.

\begin{notice}[note]
もし, 仮想ドメインを使っていて, 仮想ドメインの設定を優先させたいと
いう場合には, \ref{postfix-virtual} 節を先に読んでください!
\end{notice}

\begin{itemize}
\item \file{\var{\$prefix}/Mailman/mm_cfg.py} ファイルの最後に次のように
      追加してください:

      \begin{verbatim}
        MTA = 'Postfix'
      \end{verbatim}

      変数 MTA は \file{Mailman/MTA} ディレクトリにあるモジュールの
      名前を指定します. ここには, リストが作成／削除されるときに
      実行される, メールサーバ固有の関数が入っています.

\item \file{Defaults.py} ファイルを見て, \var{POSTFIX_ALIAS_CMD} と
      \var{POSTFIX_MAP_CMD} コマンド変数の値を確認してください.
      これらは, それぞれ \program{postalias} と \program{postmap} プログラム
      を指していなければなりません. もし変更が必要の場合は \file{mm_cfg.py}
      の中で行うようにしてください.

\item \program{bin/genaliases} スクリプトを実行して \file{aliases} 
      ファイルを初期化してください.

      \begin{verbatim}
        % cd /usr/local/mailman
        % bin/genaliases
      \end{verbatim}

      \file{data/aliases} と \file{data/aliases.db} の所有者が
      \code{mailman} で, グループ所有者が \code{mailman} であることを
      確認してください. これらは configure コマンドで設定したユーザ
      グループです. また, 両方のファイルはグループ書き込み許可が必要
      です:

      \begin{verbatim}
        % su
        % chown mailman:mailman data/aliases*
        % chmod g+w data/aliases*
      \end{verbatim}

\item Postfix の \file{main.cf} ファイルの \var{alias_maps} 変数が
      次のパスを含むように書き換えてください:

      \begin{verbatim}
          /usr/local/mailman/data/aliases
      \end{verbatim}

      最後の \code{.db} が付いていないことにも注意してください. 
      \var{alias_database} にこれを入れてはいけません. なぜなら, Postfix
      の \program{newaliases} コマンドが Mailman の \file{aliases.db} 
      ファイルを書き換えてしまうからです. しかし, ローカルアドレスを探索する
      ときには \file{aliases.db} を見てもらいます.

      このエントリについて \code{hash:} スタイルのデータベースを作りたい
      と思うでしょう. これが記入例です:

      \begin{verbatim}
        alias_maps = hash:/etc/postfix/aliases,
            hash:/usr/local/mailman/data/aliases
      \end{verbatim}

\item Mailman を configure するときに, \longprogramopt{with-mail-gid=mailman}
      スイッチを使用してください; これは \code{mailman} ユーザを追加した
      後で Mailman を configure していればデフォルトになります.
      \file{aliases.db} ファイルの所有者が \code{mailman} なので,
      Postfix は Mailman の ラッププログラムを \code{mailman} の uid と gid で
      実行します.

\end{itemize}

これで完了! 問題がひとつ: リストを作成したり削除すると, \file{aliases.db}
は更新されますが, \program{postfix reload} を自動的に実行するわけでは
ありません. これを実行するには root にならなければなりませんが, root に
suid したスクリプトは安全でないからです. Postfix が \file{aliases.db}
ファイルの変更とテーブルの更新に気が付くのに 1分ほどかかるだけです.

\subsubsection{仮想ドメイン\label{postfix-virtual}}

Postfix 2.0 は ``仮想エイリアス ドメイン\footnote{訳注：virtual alias domains. }'' をサポートします. 
これは, 以前のバージョンの Postfix では ``Postfix スタイルの仮想ドメイン''
と呼ばれていたものです. 
Mailman で動作する仮想エイリアスドメインを作るには, 
Postfix と Mailman の両方で設定をする必要があります. 
Mailman は, (既定では) \file{/usr/local/mailman/data/virtual-mailman}
という名前のファイルにすべての仮想エイリアスのマップを書き込みます. 
また, Postfix が実際に使う \program{virtual-mailman.db}
ファイルを作成するために \program{postmap} を使います. 

まず, Postfix の仮想エイリアス ドメインを Postfix の文書の説明どおりに作ります
(Postfix の \code{virtual(5)} マニュアルページを参照してください). 
マニュアルページの説明にある
\code{virtual-alias.domain anything}
の行は, 自分で入れなければいけないことに注意してください. 
Mailman は \file{virtual-mailman} にこの行を入れてくれません. 
Mailman と統合する前に, 
この仮想エイリアス ドメインが正しく動作するようにしておくことが, 
とても大事です. 

次に, Postfix と \var{virtual_alias_maps} 変数に, virtual-mailman
ファイルの位置のパス名を追加します. 例:

\begin{verbatim}
    virtual_alias_maps = <通常の仮想エイリアスのファイル>,
        hash:/usr/local/mailman/data/virtual-mailman
\end{verbatim}

ここでは, Mailman は既定の場所にインストールしてあると仮定しています. 
\var{virtual_alias_maps}
変数のない古いバージョンの Postfix を使っているのなら, 
かわりに \var{virtual_maps} 変数を使います. 

次に, \file{mm_cfg.py} ファイルで, 
\var{POSTFIX_STYLE_VIRTUAL_DOMAINS} に, 
Mailman が更新する仮想ドメインのリストを設定するとよいでしょう. 
これは, Postfix のほうでサポートする仮想ドメインすべてとは限りません!
このリストの要素は, メーリングリスト オブジェクトの \var{host_name}
属性と照合されます. 完全一致でなければいけません. 

例を挙げます. 
Postfix は仮想ドメイン \code{dom1.ain}, \code{dom2.ain}, \code{dom3.ain}, 
を扱うよう設定してあるものとし, さらに, 
\file{main.cf} ファイルに次の設定がしてあるものとします:

\begin{verbatim}
    myhostname = mail.dom1.ain
    mydomain = dom1.ain
    mydestination = $myhostname, localhost.$mydomain
    virtual_alias_maps =
        hash:/some/path/to/virtual-dom1,
        hash:/some/path/to/virtual-dom2,
        hash:/some/path/to/virtual-dom2
\end{verbatim}

たとえば \file{virtual-dom1} ファイルに, つぎの行があるとします:

\begin{verbatim}
    dom1.ain  IGNORE
    @dom1.ain @mail.dom1.ain
\end{verbatim}

これは Postfix に, \code{dom1.ain} 宛てのものはなんでも, 
\code{mail.dom1.com} の同名のメールボックス (既定の配送先) に配送するよう
指示していることになります. 

この場合, \var{POSTFIX_STYLE_VIRTUAL_DOMAINS} には \code{dom1.ain}
を含めません. なぜなら
そうしなければ, Mailman は dom1.ain ドメインのメーリングリストの項目を

\begin{verbatim}
    mylist@dom1.ain         mylist
    mylist-request@dom1.ain mylist-request
    # 等々...
\end{verbatim}

のように書き込むからです. 

より特定した項目が, より一般的な項目を上書きするので, 
\code{dom1.ain} メーリングリストへの配送は止められてしまいます. 

いっぽう, \code{dom2.ain} と \code{dom3.ain} は \file{mm_cfg.py} に含めます:

\begin{verbatim}
    POSTFIX_STYLE_VIRTUAL_DOMAINS = ['dom2.ain', 'dom3.ain']
\end{verbatim}

こうして, この二つのドメインのいずれかに属するメーリングリストを
Mailman が作ったら, \file{/usr/local/mailman/data/virtual-mailman}
には正しい項目が入ります. 

上の \file{data/aliases*} ファイルと同じく, 
\file{data/virtual-mailman} と \file{data/virtual-mailman.db}
の両方とも, \code{mailman} のユーザ, グループに
所有されているようにしたほうがいいでしょう. 

\subsubsection{他の方法}

Fil \email{fil@rezo.net} は, 
virtual マップと正規表現を使った他の方法を紹介しています. 
以下に説明があります:

\begin{itemize}
\item (フランス語)  \url{http://listes.rezo.net/comment.php}
\item (英語) \url{http://listes.rezo.net/how.php}
\end{itemize}

リストにアクセスするときのアドレスのドメインに
余分なホスト部がつくのが気にならなければ, これは良い (そしてよりシンプルな)
代替案です. 
つまり, \code{mylist@dom.ain} のかわりに \code{mylist@lists.dom.ain}
を使わないといけないのでもよければ, ということです. 

\subsection{Exim メールサーバを使う場合}
% 池田: Exim の用語は, まだ定訳のないものが多い. ここでは次のような訳語を使う:
%
% 原語                     日本語訳
% ======================= ==============
% SMTP callback (callout) SMTP 呼出し検証
% director                ダイレクタ
% domain list             ドメインリスト
% main section            首節
% recipient verification  受信者検証
% router                  ルータ
% section                 節
% transport               トランスポート

\begin{notice}[note]
本節は, Nigel Metheringham の ``HOWTO - Exim で Mailman を使う''\footnote{訳注:
``HOWTO - Using Exim and Mailman together''.} から採りました.
これは Mailman 2.0.x と Exim 3 に対応していました.
それを Mailman 2.1 と Exim 4 に対応するように改訂しました.
元の文書は次の場所にあります:
\url{http://www.exim.org/howto/mailman.html}.
\end{notice}

Mailman のインストールについて説明した箇所の標準的なオプション以外には,
Mailman の設定は必要ありません.
Exim の設定は Mailman に対して透過的です. %???
Mailman のユーザとグループの設定は,
以下に述べる設定のものと一致していなければいけません.

\subsubsection{Exim の設定}

Exim の設定では, Mailman 側で作成したリストは自動的に Exim 側で有効になります.
新たにエイリアスを定義する必要はありません.

ここで説明する設定方法の欠点は,
複数の異なるメールドメインのリストに対応したシステムでは, 満足に動作しないことです.
Mailman は, 仮想ドメインを扱えるものの,
ひとつの Mailman
のインストレーションで異なる仮想ドメインが同じ名前のリストを別々に持つことには,
まだ対応していません. そのうち変わるでしょう (なお, 後で述べるように,
仮想ドメインをもっとうまく扱う方法もあります).

以下で説明する設定は, 抜粋です.
Exim が使えるような設定になっており,
リストが属するドメインへのメールを受け付けるようになっていれば,
使えます. このドメインが Exim の設定で扱う他のドメインと分離されているときは,
次のようにする必要があります:

\begin{itemize}
\item リストのドメイン ``my.list.domain'' を \var{local_domains} に追加する

\item ``domains=my.list.domain'' オプションを, リストへのダイレクタ (ルータ)
      に追加する\footnote{訳注: 後の節で説明するダイレクタ (ルータ)
      の設定をしたあとで追加します.}

\item (必要なら) 他のダイレクタ (ルータ) からそのドメインを除外する
\end{itemize}

\begin{notice}[note]
この文書での説明は, Exim 3 と Exim 4 のどちらでも動作するようになっています.
Exim 3 では, \var{local_domains} の設定がなければいけません --- Exim 4 では,
たいていは \var{local_domains} ドメインリストのようなものがあります.
ないのなら, どこをどう調整すればうまくいくかは自分でわかっていることと思います.
また, Exim 4 では ``ダイレクタ'' の概念がなくなってしまいました --
ルータしかありません. ですから Exim 4 を使っているのなら,
この文書で ``ダイレクタ'' と言ったときは ``ルータ'' と読みかえてください.
\end{notice}

Exim 3 と Exim 4 のいずれを使っていても,
Exim 設定ファイルの 首節\footnote{訳注: main section.
Exim の設定ファイルで, 最初の ``begin ...'' 行より前の,
全般的な設定を記述する部分.}に若干のマクロを追加する必要があります.
また, 新たにトランスポートを定義する必要があります.
Exim 3 では, 新たにダイレクタを追加する必要があります ---
Exim 4 では, 新たにルータを追加して同じことをさせます.

なお, ここで提供する設定では,
Mailman 2.0 と 2.1 のインストレーションを共存させることもできます.
ただしその場合は, \code{mailman} のかわりに \code{mm21} を使うとよいかもしれません
-- 例えば,  \var{MM21_HOME}, \var{mm21_transport} などです.

\subsubsection{全般的な設定}

まず, Exim 設定ファイルの最初でいくつかマクロを追加する必要があります.
これによって, 以下で作成するダイレクタ (ルータ) とトランスポートが少し見やすくなります.
当然, Mailman をどう設定しインストールしたかによって, 変更する必要があります.

\begin{verbatim}
    # インストールした Mailman のホームディレクトリ -- つまり Mailman のプリフィクス
    # ディレクトリ
    MAILMAN_HOME=/usr/local/mailman
    MAILMAN_WRAP=MAILMAN_HOME/mail/mailman

    # Mailman のユーザとグループ. Mailman の configure スクリプトに与えた
    # --with-mail-gid スイッチと一致しなければいけない.
    MAILMAN_USER=mailman
    MAILMAN_GROUP=mailman
\end{verbatim}

\subsubsection{Exim 3\label{exim3-transport} のトランスポート}

次のものを, Exim 設定ファイルの transports 節 -- つまり,
最初と2番めの ``end'' 行の間のどこか -- に入れます:

\begin{verbatim}
  mailman_transport:
    driver = pipe
    command = MAILMAN_WRAP \
              '${if def:local_part_suffix \
                    {${sg{$local_part_suffix}{-(\\w+)(\\+.*)?}{\$1}}} \
                    {post}}' \
              $local_part
    current_directory = MAILMAN_HOME
    home_directory = MAILMAN_HOME
    user = MAILMAN_USER
    group = MAILMAN_GROUP
\end{verbatim}

\subsubsection{Exim 3 のダイレクタ}

Exim 3 を使っているのなら, 設定ファイルに以下のダイレクタを追加する必要があります
(ダイレクタは, 2つめと3つめの ``end'' 行の間にきます).  また,
順序が問題になることを忘れないでください --
例えば, このダイレクタをエイリアスファイルのダイレクタよりも前に置けば,
Mailman のリストをシステムエイリアスより優先させることができます. 逆も言えます.

\begin{verbatim}
  # リスト 'foo' (投稿アドレス) に関するアドレスすべてを扱う.
  # MAILMAN_HOME 下の lists/$local_part/config.pck を探して,
  # 自動的にリストの存在を検知する.
  mailman_director:
    driver = smartuser
    require_files = MAILMAN_HOME/lists/$local_part/config.pck
    suffix_optional
    suffix = -bounces : -bounces+* : \
             -confirm+* : -join : -leave : \
             -owner : -request : -admin
    transport = mailman_transport
\end{verbatim}

\subsubsection{Exim 4 のルータ}

Exim 4 では, ダイレクタのようなものはありません
-- かわりに, 新しくルータを追加する必要があります.
なお Exim 4 では,
設定ファイル内の標準的な順序はルータがトランスポートの前にくるように変更されたため,
まずルータについて述べます.
以下のルータを, 設定ファイルの ``begin routers'' の行の後のどこかに入れます.
ルータの順序が問題になることを忘れないでください.

\begin{verbatim}
  mailman_router:
    driver = accept
    require_files = MAILMAN_HOME/lists/$local_part/config.pck
    local_part_suffix_optional
    local_part_suffix = -bounces : -bounces+* : \
                        -confirm+* : -join : -leave : \
                        -owner : -request : -admin
    transport = mailman_transport
\end{verbatim}
% $ - emacs turds

\subsubsection{Exim 4 のトランスポート}

Exim 4 でのトランスポートは Exim 3 のものと同じです (\ref{exim3-transport}
を見てください) --- 先に示したトランスポートを, Exim 設定ファイルの
``begin transports'' 行の後のどこかにコピーします.

\subsubsection{その他の注意点}

Exim は, 充分な量の処理ができるように設定しておかないといけません
--- 例えば, \var{max_recipients} をやたらと小さな値にしてはいけません
--- また, 充分なセキュリティ強度に設定しなければいけません ---
特に, 127.0.0.1 からの中継は許可し,
ほかからはほとんど許可しないように気をつけてください\footnote{訳注:
Mailman は, MTA を通じてメールを送る際に,
HELO (EHLO) コマンドの引数として, 自ホストのプライマリ FQDN を使います.
スパム排除のために, HELO (EHLO)
の引数に自ホスト名をかたるクライアントからの配送を拒否するような設定をしている場合は,
localhost (127.0.0.1) からの配送が拒否されないように気をつけてください.}.
並列配送のようなちょっとした技巧を使ってみたければ, やってみましょう ---
設定を少しずつ変えてみて, うまくいくか確かめます. % ???
配送遅延の警告メッセージは, 出さないようにするか,
リスト以外のメールでのみ出すように設定しなければいけません.
どこかでホストが落ちるたびに大量のメールを受け取るのは嫌でしょうから.

\subsubsection{問題点}

\begin{itemize}

\item Mailman は, 必要に応じてできるだけ多くの \code{MAIL FROM}/\code{RCPT TO}
      を送ろうとします. 結果として, 一回の接続で 10 件, 100 件,
      あるいはそれ以上のメッセージが送られることもあり, Exim の
      \var{smtp_accept_queue_per_connection} の既定の値を超えてしまうかもしれません.
      これは困ったことです. なぜなら, こうなると Exim は queue モードに切り替わり,
      リストのメッセージの配送が恐ろしく遅れることになるからです.
      これを直すには, Mailman の \var{SMTP_MAX_SESSIONS_PER_CONNECTION} を
      (\file{\var{\$prefix}/Mailman/mm_cfg.py} で) Exim の
      \var{smtp_accept_queue_per_connection} より小さい値に設定します.

\item Exim はリストのメッセージに遅延警告メッセージを送ってはいけません. が,
      Mailman も Exim の遅延警告メッセージを無視しなければいけません. %% ???
      Mailman 2.1 の配送エラー処理を VERP に対応させると,
      配送エラー処理の的中率が大幅に向上します.

\item リストが存在するかどうかは, リストの \file{config.pck}
      ファイルが存在するかどうかで決めています. 誤ってリストを削除してしまったときは,
      このファイルに気をつけましょう. %% ???

\item リストにメールを送ったときに, Exim か Mailman
      でユーザIDに関するエラーが起きるのなら, \var{MAILMAN_USER} と
      \var{MAILMAN_GROUP} が Mailman 自身のものと一致するか (つまり,
      \program{configure} スクリプトで使っているものか) を調べます.
      また, エイリアスファイルに,
      リストのアドレスがエイリアスとして登録されていないかも確かめましょう.
\end{itemize}

\subsubsection{受信者検証}

Exim の受信者検証\footnote{訳注: recipient verification.}はとても役に立ちます
-- SMTPの時点で, 配送不能なアドレスを Exim が拒否するようになります.
しかし, これがいちばん役立つのは,
外部から来たメールがローカルのドメインのどれかに向かっているときです.
Mailman のリストのトラヒックは, 自サーバから出て,
サーバの預り知らない外部のさまざまなドメインへと向かいます.
そのうえ, メッセージはたくさんの受信者
-- Mailman の既定の設定を使い, \var{SMTP_MAX_RCPTS} をいじっていないときは,
最大 500 箇所 -- へ向かうことになります.

Mailman のリストのトラヒックで受信者検証をするのは, トラブルのもとです.
とりわけ, Mailman からリストの投稿が出ていくときに,
Exim は全ての受信者アドレスを検証しようとします.
ひとつひとつのアドレスについては, DNS 検索にはわずかな時間しか要さないかもしれませんが,
全体としては著しい遅延を引き起こし得ます.
したがって, Mailman のトラヒックに対しては受信者検証を無効にしなければいけません.

Exim 3 では, 首節に以下のものを入れます:

\begin{verbatim}
    receiver_verify_hosts = !127.0.0.1
\end{verbatim}

Exim 4 では, この点についてはおそらく
(\code{RCPT TO} ACL 中の) 既定の ACL 文では考慮されていることでしょう: % ???

\begin{verbatim}
  accept  domains       = +local_domains
          endpass
          message       = unknown user
          verify        = recipient
\end{verbatim}

これで, 自分のドメインのアドレスに対してだけ受信者検証をするようになります
(これは厳密には, 127.0.0.1
以外のホストから来るメッセージだけに対して受信者検証をすることとは違いますが,
Mailman にはよく効きます).

\subsubsection{SMTP 呼出し検証}

Exim の SMTP 呼出し検証\footnote{訳注:
SMTP callback.}の仕様は, でたらめな送信者アドレスを検出する方法としては,
通常の送信者検証にくらべてはるかに強力です. ところが困ったことに,
バウンスメッセージのヘッダにでたらめなアドレスを入れて送るサーバはたくさんありますし,
また (バウンスメッセージには空のエンヴェロープ送信者を使うことになっているにも関わらず)
でたらめなエンヴェロープ送信者を使ってバウンスメッセージを送るサーバも,
少なからずあるのです.

Mailman が,
バウンスの発生しているアドレスをきちんと配送停止したり登録を抹消したりできるように,
Mailman のリストへ届くバウンスメッセージは,
たとえそういったバウンスメッセージそれ自体はバウンス不可能なものであっても,
受け取るようにしたほうがいいでしょう. そのため, バウンスメッセージに対しては,
SMTP 呼出し検証は無効にするとよいかもしれません.

Exim 4 でこれを実現するには, \code{RCPT TO} ACL で以下のようなものを使います:

\begin{verbatim}
  # 呼出し検証などの検査が失敗したとしても, リストへのバウンスメッセージは受け付ける
  warn     message      = X-WhitelistedRCPT-nohdrfromcallback: Yes
           condition    = \
           ${if and {{match{$local_part}{(.*)-bounces\+.*}} \
                     {exists {MAILMAN_HOME/lists/$1/config.pck}}} \
                {yes}{no}}
                {yes}{no}}

  accept   condition    = \
           ${if and {{match{$local_part}{(.*)-bounces\+.*}} \
                     {exists {MAILMAN_HOME/lists/$1/config.pck}}} \
                {yes}{no}}
                {yes}{no}}

  # そして, SMTP 呼出し検証で送信者アドレスを調べる.
  deny   !verify = sender/callout=90s
\end{verbatim}

ヘッダのアドレスにも SMTP 呼出し検証をしたければ, 次のようなものを \code{DATA} ACL
に入れるとよいでしょう.

\begin{verbatim}
  deny   !condition = $header_X-WhitelistedRCPT-nohdrfromcallback:
         !verify = header_sender/callout=90s
\end{verbatim}
% $ - emacs turd

\subsubsection{Exim と Mailman で VERP を使う}

VERP では, 一つのメールを, リストの購読者ごとに別々の送信者 (返送経路) で送ります
-- VERP を使えるようにするためのオプションについては
\file{\var{\$prefix}/Mailman/Defaults.py} の情報を読んでください.
まとめると, Exim で VERP を有効にするのに必要なことは,
\file{\var{\$prefix}/Mailman/mm_cfg.py} に次の行を追加することです:

\begin{verbatim}
    VERP_PASSWORD_REMINDERS = Yes
    VERP_PERSONALIZED_DELIVERIES = Yes
    VERP_DELIVERY_INTERVAL = Yes
    VERP_CONFIRMATIONS = Yes
\end{verbatim}

(先に説明したダイレクタ (ルータ) は,
VERP のバウンスメッセージをちゃんと処理できるようになっています. )

\subsubsection{仮想ドメイン}

仮想ドメインを扱う手法のひとつとして,
仮想ドメインごとに別々の Mailman をインストールするというものがあります.
現時点では,
ひとつの計算機で異なる仮想ドメインが同じ名前のリストを別々に持てるようにするには,
この方法しかありません\footnote{訳注:
異なる仮想ドメインで同じ名前のリストを別々に使えなくてもかまわなければ,
本節の設定は不要です.}.

この場合, マクロ \var{MAILMAN_HOME} と \var{MAILMAN_WRAP} は使えません
-- 削除してしまってかまいません. ダイレクタ (ルータ) を次のように変更します:

\begin{verbatim}
  require_files = /virtual/${domain}/mailman/lists/${lc:$local_part}/config.pck
\end{verbatim}
% $ - emacs turd

そして, トランスポートを次のように変更します:

\begin{verbatim}
  command = /virtual/${domain}/mailman/mail/mailman \
            ${if def:local_part_suffix \
                 {${sg{$local_part_suffix}{-(\\w+)(\\+.*)?}{\$1}}}
                 {post}} \
              $local_part
  current_directory = /virtual/${domain}/mailman
  home_directory = /virtual/${domain}/mailman
\end{verbatim}
% $ - emacs turd

\subsubsection{リストの検証}

ここでは, Exim のアドレステストセットを使って,
システムの動作の様子を調べる方法を説明します. % ???
問題のリストを \email{quixote-users@mems-exchange.org} とし,
次の一連のコマンドを \code{mems-exchange.org} メールサーバで実行します ("\% "
は Unix のシェル プロンプトを表します):

\begin{verbatim}
  % exim -bt quixote-users
  quixote-users@mems-exchange.org
    router = mailman_main_router, transport = mailman_transport

  % exim -bt quixote-users-request
  quixote-users-request@mems-exchange.org
    router = mailman_router, transport = mailman_transport

  % exim -bt quixote-users-bounces
  quixote-users-bounces@mems-exchange.org
    router = mailman_router, transport = mailman_transport

  % exim -bt quixote-users-bounces+luser=example.com
  quixote-users-bounces+luser=example.com@mems-exchange.org
    router = mailman_router, transport = mailman_transport
\end{verbatim}

\program{exim -bt} の出力がここに示したようなものになっていれば,
ここまでは順調と言えます: % that's a start ???
少なくとも,
Exim が適切なメッセージを適切な Mailman のコマンドに渡していることは確認できました.
しかし, インストールしてある Exim/Mailman が,
完全に正しく動作しているという保証はありません!

\subsubsection{この文書の履歴}

元になる文書は Nigel Metheringham \email{postmaster@exim.org} が書きました.
Marc Merlin \email{marc_soft@merlins.org} が
Mailman 2.1 と Exim 4 用に改訂しました.
Greg Ward \email{gward@python.net} が書き直し/再構成/明確化/簡略化しました.

\subsection{Sendmail メールサーバを使う場合}

\begin{notice}[warning]
Sendmail メールサーバを使うとき, 
\file{mm_cfg.py} の中に \var{DELIVERY_MODULE} 設定変数として \code{'Sendmail'}
を入れたいと思うかもしれませんが, そうしては\strong{いけません}.
\file{Sendmail.py} のモジュール名は
間違って付けられています.
デフォルトの \file{SMTPDirect.py} で使う SMTP 方式に対して, コマンドラインで
メッセージを渡す方式を表しています.
\file{Sendmail.py} ファイルには既知のセキュリティホールがあり
概念的可能性を証明するために提供されています\footnote{実際, Mailman の
最近のバージョンでは, このモジュールをわざと動かなくしてあります.
もしこれを有効にしたいのであれば, なにが起こるかよく理解していなければ
いけません.}.
もし \file{SMTPDirect.py} の利用で問題があるなら \file{Sendmail.py} を
使うのでなく, 問題を直すことです. でないとセキュリティ悪用にさらす
ことになりかねません.
\end{notice}

\subsubsection{Sendmail の ``smrsh'' との適合}

新しいバージョンの Sendmail は Sendmail がメールプログラムとして
使うことを制限するために ``smrsh'' という制限実行ユーティリティが
付いてきます. 明示的に Mailman のラッププログラムが smrsh で使える
ようにしてあげないと Mailman は動作しません. もしメールが Mailman の
ラッププログラムに届かず, ``operating system error'' がメールの
ログに記録されていれば, この問題に突き当たっていることになります.

これを解決するのによい方法は:

\begin{itemize}
    \item Sendmail が smrsh ラッププログラムをどこで実行しているかを探す:

          \begin{verbatim}
            % grep smrsh /etc/mail/sendmail.cf
          \end{verbatim}

    \item 実行許可するメールプログラムを smrsh がどこにシンボリック
          リンクしているかを探す. 次のコマンドの最初のほうでどこかの
          ディレクトリ(例えば \file{/var/adm/sm.bin} みたいな)のパス
          が出てくるでしょう:

          \begin{verbatim}
            % strings $path_to_smrsh | less
          \end{verbatim}

    \item \file{/var/adm/sm.bin} あるいは自分のシステムで見つけた
          ディレクトリ (\file{/etc/smrsh} とか \file{/var/smrsh} とか
          \file{/usr/local/smrsh} とか...) へ移って:

          \begin{verbatim}
            % cd /var/adm/sm.bin
          \end{verbatim}

    \item Mailman のラッププログラムへのシンボリックリンクを作成します:

          \begin{verbatim}
            % ln -s /usr/local/mailman/mail/mailman mailman
          \end{verbatim}
\end{itemize}

\subsubsection{Sendmail と Mailman の統合}

David Champion は Sendmail と Mailman をより密接に統合する, つまり
リストが作成されたときにエイリアステーブルを手で編集しなくても, 
Sendmail が自動的に認識し新しいリストに配送するようにするための
レシピを寄贈してくれました.

Mailman のソース配布物 \file{contrib} ディレクトリに次の4つの
ファイルがあります:

\begin{itemize}
\item \file{mm-handler.readme} - セットアップする方法の説明
\item \file{mm-handler}        - メール配送エージェント (MDA)
\item \file{mailman.mc}        - 設定ファイルの例
\item \file{virtusertable}     - RFC 2142 アドレスを例外にする例
\end{itemize}

\subsubsection{性能について}

Sendmail で性能を落とす要因として確実なのは, 受信者のホストを DNS 
で同時に検証するように設定されている場合です. Mailman からサーバに
メールが送信されるときにこれをやると非常に性能が落ちます.
Mailman は \code{localhost} (つまり, 127.0.0.1) から Sendmail の
SMTP ポートに接続しますので, ローカルホストからの接続については
DNS での同時検証を\strong{しない}ように Sendmail を設定してください.

\subsection{qmail メールサーバを使う場合\label{qmail-issues}}

ここでは, qmail メール配送エージェントを使うユーザがぶつかった問題をいくつかとりあげます.
Mailman の中心的なメンテナで qmail を使っている者はいませんので, 
以下の情報はすべて, Mailman のユーザ コミュニティから寄贈されたものです.
とりわけ, Martin Preishuber と Christian Tismer, そして Balazs Nagy (以下 BN) と
Norbert Bollow (以下 NB) の注釈に負っています.

\begin{itemize}
\item \longprogramopt{with-mail-gid} \program{configure} オプションを使って, 
      mail-gid のユーザを, \code{qmail}, \code{mailman}, \code{nofiles}
      のいずれかにする必要がありそうです.

      \emph{BN:} どれを選ぶかは, メール格納の方針に大いに依存します.
      たとえば, 単純な \file{\~{}alias/.qmail-*} ファイルを使っているのなら, 
      \program{`id -g alias`} を使います\footnote{訳注:
      ユーザ \code{alias} の GID を使う, という意味です.}.
      しかし \file{/var/qmail/users} を使っているのなら, 
      そこで指定したメール gid を使うことになります.

      仮想ドメインのアドレスが直接 \code{mailman} ユーザに向かうようにしている
      (たとえば, メーリングリスト専用のドメインに ``virtualdomains'' を使っている)
      のなら, \longprogramopt{with-mail-gid}=\var{mailmanユーザのグループのGID}
      を使わなければならないでしょう.
      これは, リストのエイリアスを \file{\~{}alias} に入れることとは両立しません.
      こういうエイリアスは, 
      \code{mailman-リスト名*} を転送するものになってしまいます.
      

\item システムにユーザ \code{mailman} があると, エイリアス
      \code{mailman-owner} は \file{\~{}mailman} の中でだけ動作します.
      \file{\~{}mailman} ディレクトリの中で \program{touch .qmail-owner} すると, 
      このエイリアスを作成できます.

      \emph{NB:} かわりに, 私がより良い解決策かと思うのが, \program{chown
      root \~{}mailman} をすることで, こうすると qmail は \code{mailman} 
      を, メールを配送できるユーザとみなさなくなります 
      (``man 8 qmail-getpw'' を見てください)\footnote{訳注:
      \code{mailman} ユーザのホームディレクトリが存在しない場合
      (「グループとユーザの追加」の節の手順のとおりにするとそうなります) も, 
      qmail は \code{mailman} を, メールを配送できるユーザとみなしません.}.

\item 関連する話題として, メーリングリストのどれかと同じ名前のユーザがあると, 
      \samp{-} があるリスト名で問題が起きる, というものがあります.
      そのユーザのホームディレクトリに \file{.qmail} リダイレクションファイルを置いても, 
      Mailman のラッパを正しい GID で呼び出せないため, 動作しません.
      解決策は, \file{/var/qmail/users/assign} ファイルに次のような行を入れることです:

\begin{verbatim}
  +zope-:alias:112:11:/var/qmail/alias:-:zope-:
  .
\end{verbatim}

      これは, リスト名が \code{zope-users} などである場合です.

      \emph{NB:} かわりに, リストを仮想ドメインで扱うことにして, 
      \file{/var/qmail/control/virtualdomains} ファイルを使って
      この仮想ドメインを \code{mailman} ユーザで管理させることもできます.

\item \emph{BN:}受け取るメッセージを \code{mailman} 以外のユーザで配送するときは, 
      そのユーザが \file{\~{}mailman} にアクセスできるようになっていることが必須です.
      \file{\~{}mailman} にグループ書き込み権限があって, 
      setgid ビットがセットしてあることを確かめます.
      そして, 配送するユーザを \code{mailman} グループに入れますが, 
      ほかのユーザは \file{\~{}mailman} にアクセスできなくしてもよいでしょう.
      WWW サービスについても同じようにできます.

      とにかく, すべてのメールを扱う仮想メールサーバをつくるのが最善のやりかたです.
      \emph{NB:} たとえば, 仮想メールサーバ用に
      自分の IP アドレスを指す DNS "A" レコードを追加した上で, 
      \file{/var/qmail/control/virtualdomains} ファイルに
      \code{lists.kva.hu:mailman} という行を, 
      \file{/var/qmail/control/rcpthosts} ファイルに
      \code{lists.kva.hu} という行を, それぞれ追加します.
      ``virtualdomains'' を変更したら, 
      qmail-send に HUP シグナルを送るのを忘れないようにしてください.
      これで, lists.kva.hu 宛のすべてのメールは
      mail.kva.hu の mailman ユーザに届くようになります.

      それから, エイリアスを作成します:

\begin{verbatim}
          .qmail              => mailman@...へのメール
          .qmail-owner        => mailman-owner へのメール
\end{verbatim}
%% [池田] 仮想メールサーバにした場合, mailman*@... は mailman-mailman*@..
%% に配送されるので, 上記のエイリアスは不要では?

      リストのエイリアスについては, 次のように手動で作成することもできます:

\begin{verbatim}
          .qmail-list         => 'list' リストへの投稿
          .qmail-list-admin   => 'list' の管理者への投稿
          .qmail-list-request => 'list' への要求
          など
\end{verbatim}

      あるいは, (上のように, lists.kva.hu を仮想で使っているときは)
      リストエイリアスの自動把握をすることもできます.  Mailman のソース配布物にある
      \file{contrib/qmail-to-mailman.py} を見てください\footnote{訳注:
      qmail-to-mailman.py は, 仮想メールサーバでないアドレスにも使えるでしょう.}.
      \file{\~{}mailman/.qmail-default} を変更して, 次のものを含めます:

\begin{verbatim}
          |preline /path/to/python /path/to/qmail-to-mailman.py
\end{verbatim}

      すると, 新しいリストを自動的にみつけてくれるようになります.

\item localhost がメールをリレーできるように気をつけなければいけません.
      qmail を inetd と tcpenv を通じて起動しているのなら, 
      \file{/etc/hosts.allow} につぎのような行が必要です:

\begin{verbatim}
      tcp-env: 127. 10.205.200. : setenv RELAYCLIENT
\end{verbatim}

      ここで 10.205.200. は, 自分の IP アドレスブロックです.
      tcpserver を使っているのなら, \file{/etc/tcp.smtp} ファイルに
      次のようなものが必要です:

\begin{verbatim}
      10.205.200.:allow,RELAYCLIENT=""
      127.:allow,RELAYCLIENT=""
\end{verbatim}

\item \emph{BN:} \file{/var/qmail/control/concurrencyremote}
      の値は, 常識的な範囲で増やせば, メッセージの送出がより速く動作するようになります.
      ただし, システムがさばける数 %% (many if not most cannot) ???
      だと分かっていない限り, 
      この値は 120 より大きくしてはなりません.

\item qmail とリレーの設定についてのさらなる情報は, qmail の文書にあります.
\end{itemize}

\emph{BN:} 最後に, リストのエイリアスを生成するスクリプトを挙げておきます
(なんらかの理由で, \file{contrib/qmail-to-mailman.py} 
を使って自動的にエイリアスを拾い出すことができなかったり, そうしたくないときに使います):

Mailman 2.0 系列のためのスクリプト:

\begin{verbatim}
#!/bin/sh
if [ $# = 1 ]; then
    i=$1
    echo カレントディレクトリに $i へのリンクを作っています...
    echo "|preline /home/mailman/mail/mailman post $i" > .qmail-$i
    echo "|preline /home/mailman/mail/mailman mailowner $i" > .qmail-$i-admin
    echo "|preline /home/mailman/mail/mailman mailowner $i" > .qmail-$i-owner
    echo "|preline /home/mailman/mail/mailman mailowner $i" > .qmail-owner-$i
    echo "|preline /home/mailman/mail/mailman mailcmd $i" > .qmail-$i-request
fi
\end{verbatim}
% $ - emacs turd

\begin{notice}[note]
以下のスクリプトは, 新たにインストールした Mailman 2.1 のためのものです.
Mailman 2.0 からアップグレードするユーザだと, ディレクトリを
\file{/usr/local/mailman} から \file{/home/mailman} に変えたがるかもしれません.
これをはっきり指定するには, % ???
コンパイルのときに \program{configure} に
\longprogramopt{prefix} オプションを渡します.
\end{notice}

\begin{verbatim}
#!/bin/sh
if [ $# = 1 ]; then
    i=$1
    echo カレントディレクトリに $i へのリンクを作っています...
    echo "|preline /usr/local/mailman/mail/mailman post $i" > .qmail-$i
    echo "|preline /usr/local/mailman/mail/mailman admin $i" > .qmail-$i-admin
    echo "|preline /usr/local/mailman/mail/mailman bounces $i" > .qmail-$i-bounces
    # 次の行は VERP 用
    # echo "|preline /usr/local/mailman/mail/mailman bounces $i" > .qmail-$i-bounces-default
    echo "|preline /usr/local/mailman/mail/mailman confirm $i" > .qmail-$i-confirm
    echo "|preline /usr/local/mailman/mail/mailman join $i" > .qmail-$i-join
    echo "|preline /usr/local/mailman/mail/mailman leave $i" > .qmail-$i-leave
    echo "|preline /usr/local/mailman/mail/mailman owner $i" > .qmail-$i-owner
    echo "|preline /usr/local/mailman/mail/mailman request $i" > .qmail-$i-request
    echo "|preline /usr/local/mailman/mail/mailman subscribe $i" > .qmail-$i-subscribe
    echo "|preline /usr/local/mailman/mail/mailman unsubscribe $i" > .qmail-$i-unsubscribe
fi
\end{verbatim}
% $ - emacs turd

\subsubsection{VERP についての情報}

上記の 2.1 用エイリアス生成スクリプトでは, VERP 用の行がコメントアウト
してあるのに気づいたことでしょう.  VERP に関心があるのなら, 2つの選択
肢があります.  一つめは Mailman に VERP 書式化をおこなわせるものです.
これを有効にするには, 上のスクリプトでコメントを外し, \file{mm_cfg.py} 
ファイルに次の行を加えます:

\begin{verbatim}
    VERP_FORMAT = '%(bounces)s-+%(mailbox)s=%(host)s'
    VERP_REGEXP = r'^(?P<bounces>.*?)-\+(?P<mailbox>[^=]+)=(?P<host>[^@]+)@.*$'
\end{verbatim}
% $ - emacs turd

別の選択肢として, SourceForge にあるパッチも使えます.  次の場所にあります:

\url{http://sourceforge.net/tracker/?func=detail\&atid=300103\&aid=645513\&group_id=103}

このパッチは現時点では, テストが充分とは言えないので, 
開発者や qmail についてよく分かっている人向きでしょう.  聞くところによると, 
このパッチは qmail とより調和するアプローチで, 効率を大きく改善させるとのことです.

\subsubsection{仮想メール サーバ}

\ref{qmail-issues} 節でも仮想メールサーバについては触れましたが, 
テスト中のパッチが以下の場所にあります:

\url{http://sf.net/tracker/index.php?func=detail\&aid=621257\&group_id=103\&atid=300103}

念のため.  このパッチも, qmail のインストールについてよく分かっている人向けです.

\subsubsection{更なる情報}

メッセージフッタの変更についての情報に関心があるようなら, 
Norbert Bollow が Mailman と qmail について書いたものがあります.  次の場所にあります:

    \url{http://mailman.cis.to/qmail-verh/}\footnote{訳注:
    翻訳時点ではアクセスできませんでした.}

\section{サイトのデフォルトを点検\label{customizing}}

Mailman には沢山のサイト全体の設定オプションがありますので, ここで点検し, 
必要に応じて変更してください.
オプションのいくつかは Mailman があなたの環境でどう動作するかを制御し,
あるいは新規に作成したリストのデフォルトを選びます\footnote{
一般的に, ここで変更したリストのデフォルトは既に作成済みのリストには
適用されません. リストが作成された後に変更を加えるには, ウェブインタフェース
を使うか \program{bin/withlist} や \program{bin/config_list} のような
コマンド行スクリプトを使います.}.
またシステムチューニングのパラメータや統合のオプションがあります.

\file{\var{\$prefix}/Mailman/Defaults.py} ファイルにサイト全体の
デフォルトの全部が入っています. しかし, \strong{絶対} このファイルを
変更してはいけません. その代わり, 同じディレクトリにある,
\file{mm_cfg.py} ファイルを変更してください. \file{Defaults.py} に
入っているのと違うものだけ \file{mm_cfg.py} に書き加えればよいだけです.
将来 Mailman をバージョンアップする時に, \file{mm_cfg.py} が書き換えられる
ことはありません.

\file{Defaults.py} ファイルにはコメントが沢山書いてあります. そこで
オプションをここで説明することはしません. \file{Defaults.py} と \file{mm_cfg.py}
はどちらも \ulink{Python}{http://www.python.org} ファイルなので
Python の文法を守るようにしないといけません. でないと Mailman は動きません.

\begin{notice}[note]
\var{HOME_DIR} と \var{MAILMAN_DIR} 変数を変えては \strong{いけません}.
これらは \program{configure} スクリプトで自動的に設定されます.
もし変えると Mailman のインストールが壊れます.
\end{notice}

\file{mm_cfg.py} の変更は \ref{building} 節で Mailman を
インストールしたときのユーザでおこなう必要があります.

\section{サイト全体のメーリングリストを作る}

Mailman とメールサーバの統合を完成させたら, 次に ``サイト全体'' の
メーリングリストを作る必要があります. これはパスワード備忘通知の発信者
として現れるものであり, Mailman を正しく運用するのに必要なものです.
通常, これは \code{mailman} という名前のリストですが, 変更する必要が
ある場合は, \file{mm_cfg.py} の中で \var{MAILMAN_SITE_LIST} 変数を
変更してください. 次のプロンプトに続くコマンドでこのサイトリストを
作成することができます.

\begin{verbatim}
    % bin/newlist mailman
\end{verbatim}

ここで, サイトリストの設定をします. これの助けになるように,
サイトリストの便利なひな形が \file{data/sitelist.cfg} に作って
あります. このひな形の設定オプションについて見ておいてください.
\file{sitelist.cfg} ファイルに名前が出ていないオプションについては
変更されないことも注意してください.

このひな形を適用するには次のようにします:

\begin{verbatim}
    % bin/config_list -i data/sitelist.cfg mailman
\end{verbatim}

\file{sitelist.cfg} のオプションを適用の後で, リストの管理ページで
設定を見ておくことを忘れないでください.
ください.

サイトリストには自分自身を登録しておいてください.

\section{Cron の設定}

多くの Mailman の仕事は定常的なスケジュールで発生します. そのため,
正しい時刻に正しいプログラムを実行するよう \program{cron} を設定しなければ
なりません\footnote{以前のバージョンから更新するときには, 新しい
crontab を入れないといけないかもしれません. しかし, 複数の Mailman を
インストールしている場合には注意が必要です. crontab を変更すると
他の平行した Mailman を壊すかもしれません.}.

もし, あなたの crontab が \programopt{-u} オプションをサポートして
いたら, root になって次のステップを実行してください. 
次のコマンドを実行して \file{\var{\$prefix}/cron/crontab.in} を
crontab のエントリに入れます.

\begin{verbatim}
    % cd $prefix/cron
    % crontab -u mailman crontab.in
\end{verbatim}

もし, \longprogramopt{with-username} オプションを使っていたら, \programopt{-u}
の引数には \code{mailman} の代わりにそのユーザ名を使います.
もし, crontab が \programopt{-u} オプションをサポートしていなければ,
次のようにしてください:

\begin{verbatim}
    % cd $prefix/cron
    % su - mailman
    % crontab crontab.in
\end{verbatim}

\section{Mailman の qrunner を起動する}

Mailman は全てのメール配送に ``qrunner'' と呼ばれるプロセスを使います.
\var{\$prefix} に移動して, 次のコマンドを実行することで qrunner を
起動する必要があります:

\begin{verbatim}
    % bin/mailmanctl start
\end{verbatim}

システムをリブートするたびに Mailman を起動したほうがよいでしょう.
実際にどうするかは使用するオペレーティングシステムに依存します.
OS が \program{chkconfig} コマンドをサポートしていれば (例えば Red Hat
や Mandrake の Linux) 次のようにしてください (Mailman の
インストールディレクトリから, root になって):

\begin{verbatim}
    % cp scripts/mailman /etc/init.d/mailman
    % chkconfig --add mailman
\end{verbatim}

\file{/etc/init.d} はシステムによっては \file{/etc/rc.d/init.d} かも
しれません.

Gentoo Linux では次のようにします:

\begin{verbatim}
    % cp scripts/mailman /etc/init.d/mailman
    % rc-update add mailman default
\end{verbatim}

Debian ではこうするとよいでしょう:

\begin{verbatim}
    % update-rc.d mailman defaults
\end{verbatim}

\program{chkconfig} をサポートしない \UNIX{} では次の一連のコマンド
を試してみるとよいかもしれません:

\begin{verbatim}
    % cp scripts/mailman /etc/init.d/mailman
    % cp misc/mailman /etc/init.d
    % cd /etc/rc.d/rc0.d
    % ln -s ../init.d/mailman K12mailman
    % cd ../rc1.d
    % ln -s ../init.d/mailman K12mailman
    % cd ../rc2.d
    % ln -s ../init.d/mailman S98mailman
    % cd ../rc3.d
    % ln -s ../init.d/mailman S98mailman
    % cd ../rc4.d
    % ln -s ../init.d/mailman S98mailman
    % cd ../rc5.d
    % ln -s ../init.d/mailman S98mailman
    % cd ../rc6.d
    % ln -s ../init.d/mailman K12mailman
\end{verbatim}

\section{ホスト名の設定をチェックする}

\file{Defaults.py} の中の \var{DEFAULT_EMAIL_HOST} と \var{DEFAULT_URL_HOST}
をチェックしてください. 変更が必要な場合は \file{Defaults.py} で \strong{なく}
\file{mm_cfg.py} に書きます. 
また, どちらかの値を変更したときには, \file{mm_cfg.py} の変更の後に,
次のように追加してください.

\begin{verbatim}
    add_virtualhost(DEFAULT_URL_HOST, DEFAULT_EMAIL_HOST)
\end{verbatim}

もし既に作成したリストがあったら, \program{bin/fix_url.py} を使って
ドメイン名を変更してください.

\section{サイトパスワードの作成}

\program{bin/mmsitepass} スクリプトを使用すると, コマンドラインから
２つのサイト全体のパスワードを作成できます.
一つ目は, ``サイトパスワード'' でシステム上でパスワードが必要の
場合はどこでも使うことができます. サイトパスワードはどのリストの
管理ページへも入ることができますし, どのユーザとしてもログインできます.
Unix システムでの \code{root} を考えてください. このパスワードは
賢く考えて選んでください.

２番目のパスワードはサイト全体の ``リスト作成'' パスワードです.
これを使うと, サイトパスワードの全ての特権を与えずに, 新しいリストを
作成するだけの権限を持たせることができます.
もちろん, サイトパスワードでも新しいメーリングリストを作成できますが,
リスト作成パスワードは特別の役割だけに限定するものです.

サイトパスワードの設定には次のコマンドを使います:

\begin{verbatim}
    % $prefix/bin/mmsitepass <あなたのサイトパスワード>
\end{verbatim}

リスト作成パスワードの設定は次のコマンドを使ってください:

\begin{verbatim}
    % $prefix/bin/mmsitepass -c <リスト作成パスワード>
\end{verbatim}

リスト作成パスワードを設定しなくても結構ですが, サイトパスワードは
必要になるはずです.

\section{初めてリストを作成する}

Mailman を使うに当たってリストを作成したり設定したりといった詳しい情報
については, Mailman リスト管理マニュアルを参照してください.
ここでは, ウェブインタフェースを使って最初のメーリングリストを作成
するための簡単なガイドを説明します:

\begin{itemize}
\item まず URL \code{http://my.dom.ain/mailman/create} を開いてください.

\item 画面に出ている指示に従ってフォームに記入して, ``リスト作成者の
      パスワード'' のところに \ref{customizing} 節で作成した
      パスワードを入れてください. 自分のメールアドレスを
      ``リスト管理者アドレスの初期設定'' のところに入れ, 
      ``「リスト作成完了」をメールで管理者に知らせますか'' で ``はい'' を
      選んでください.

\item ``リストを作成する'' ボタンをクリックしてください.

\item Mailman からあなた宛に新しいメーリングリストが作成されたことを
      メールで知らせますのでチェックしてください.

\item 確認のウェブページか Mailman が送信したメールに書かれたリンクを
      たどって, リストの管理ページへ行って下さい. たいがいは, URL は
      \code{http://my.dom.ain/mailman/admin/mylist} みたいになってる
      はずです.

\item リストのパスワードを入れて, ``ログイン...'' をクリックします.

\item ``会員管理'' をクリックし, 続いて ``まとめて入会登録'' へ行って
      ください.

\item 大きいテキスト入力エリアに自分のメールアドレスを入れ,
      ``変更を送信する'' をクリックしてください.

\item 自分のメールソフトで, \code{mylist@my.dom.ain} 宛てにメールを
      出してください. 1,2分のうちに, Mailman 経由で自分のメールが返って
      来るでしょう.
\end{itemize}

おめでとう! あなたの最初のメーリングリストの設定とテストが完了しました.
何か問題が起こったら, \ref{troubleshooting} 節を見てください.

\section{トラブルと対策\label{troubleshooting}}

もし, Mailman の実行で問題が発生したら, まず以下の「一般的な
問題」の節をチェックしましょう．もし，問題がそこに含
まれていなければ，\ulink{オンラインヘルプ}{http://www.list.org/help.html}
を見てください. そこから, \ulink{FAQ}{http://www.list.org/faq.html}
と \ulink{インタラクティブな FAQ ウィザード}{http://www.python.org/cgi-bin/faqw-mm.py}
へ行くことができます.

それから，システムの syslog と, Mailman の
\file{\var{\$prefix}/logs/error} ファイルにエラーが入っていないかもチェック
しましょう．
それでも問題があれば, \email{mailman-users@python.org} メーリングリスト
\footnote{メールを投稿するにはこメーリングリストに入らないといけませんが,
リストの保存書庫は一般公開されています.} に質問を書いてください.
\url{http://mail.python.org/mailman/listinfo/mailman-users} に詳しい
案内があります.

オペレーティングシステムや, 使用している Python のバージョン,
インストール中の Mailman のバージョンなどについての情報も
忘れずに入れてください.

以下は, 一般的な質問と回答のリストです:
Here is a list of some common questions and answers:

\begin{itemize}

\item \strong{問題:} Mailman の ウェブページが全て 404 File not found エラーに
      なります.

      \strong{解決法:} ウェブサーバの設定で Mailman の CGI コマンドを正しく
      扱えるように設定できていません. 以下を確認:

      \begin{enumerate}
      \item ウェブサーバで \file{\var{\$prefix}/cgi-bin} に正しく許可
            (パーミッション) を設定する.

      \item ウェブサーバを正しく再起動する.
      \end{enumerate}

      ウェブサーバの説明書をよく読んでどうしたらよいか調べてください.

\item \strong{問題:} Mailman のウェブページが全て "Internal Server
      Error" になります.

      \strong{解決法:} 間違ったユーザまたはグループを使って CGI を
      実行しようとしている可能性があります. ウェブサーバのログをチェックして
      ください. 例えば以下のような行があったら,

      \begin{verbatim}
            Attempt to exec script with invalid gid 51, expected 99
      \end{verbatim}

      Mailman を再インストールしなければなりません. \label{building} 
      節に書かれていたように, 正しい CGI グループ ID を指定して
      ください.

\item \strong{問題:} メールをリストに送ったら, リストが見つからないという
      メールを受け取りました.

      \strong{解決法:} 多分, システムのエイリアスデータベースに必要な
      エイリアスを登録していなかったのでしょう. あるいは, Mailman と
      メールサーバの組み合わせが正しく行われていないのかもしれません.
      エイリアスデータベースを更新していないか, あなたのシステムでは
      \program{newaliases} を明示的に実行する必要があるのかしれません.
      あなたがご利用のサーバについて\ref{mail-server}節で
      確認してください.

\item \strong{問題:} リストにメールを送ったら, ``unknown mailer error''
      が帰ってきました.

      \strong{解決法:} メールラップで間違ったユーザまたはグループID
      を使っている可能性があります. メールサーバのログをチェックして
      ください. 次のような行があったら,

      \begin{verbatim}
            Attempt to exec script with invalid gid 51, expected 99
      \end{verbatim}

      Mailman を再インストールしなければなりません. \label{building}
      節に書かれていたように, 正しいメールグループ ID を指定して
      ください.

\item \strong{問題:} 私は Postfix をメールサーバに使っています.
      そして, メールラッププログラムは GID が違っていると不平をログに残します.

      \strong{解決法:} \file{\var{\$prefix}/data/aliases.db} ファイルの
      所有者が \code{mailman} (又は \program{configure} コマンドで使った名前) 
      であることを確認してください. もし \code{mailman} 以外のユーザに
      所有されている場合は, Postfix は正しいユーザでメールプログラムを
      実行しません.

\item \strong{問題:} 私は Sendmail をメールサーバに使っています.
      そして, メールをリストに送ると 
      ``sh: mailman not available for
      sendmail programs'' というメールが返ってきます.

      \strong{解決法:} あなたのシステムでは Sendmail restricted shell
      (smrsh) が使われています. メールラッププログラム
      (\file{\var{\$prefix}/mail/mailman}) から smrsh で実行が許可されて
      いるディレクトリにシンボリックリンクを張る必要があります.

      一般的にこのディレクトリは \file{/var/admin/sm.bin},
      \file{/usr/admin/sm.bin}, \file{/etc/smrsh} などに設定されています.

      Debian Linux ではシステムは \file{/usr/lib/sm.bin} を作成します
      が，これは間違っています. \file{/usr/admin/sm.bin} を 作ってそ
      こへリンクを作成する必要があります. 
      注：\program{newaliases} が吐き出すどのエイリアスもラップへの
      安全なリンクを指す必要があります．

\item \strong{問題:}  \program{configure} を呼び出すときに散らかして
      しまいました. 掃除をして再インストールするにはどうしたらいいですか?

      \strong{解決法:}

      \begin{verbatim}
        % make clean
        % ./configure --with-the-right-options
        % make install
      \end{verbatim}

\end{itemize}

\section{プラットフォームやオペレーティング システムごとの注}

一般に, Mailman は POSIX 準拠のシステム (Solaris, 
BSD のさまざまな変種, Linux 系システム, MacOSX, 
その他の \UNIX{} システムなど) でなら動作します. 
Windows では動作しません. 
たいていの場合, 
Mailman がサポートされているプラットフォームで動作するようにするには, 
この文書で説明した一般的な手順だけで充分です. 
しかし, 一部のオペレーティング システムでは, 
このほかに, インストールや設定の際に推奨される手順があります. 

\subsection{GNU/Linux について}

Linux は, Mailman を実行するプラットフォームとしては, 
もっとも普及しているもののようです. 
Mailman を Linux で実行できるようにするためのヒントをいくつか挙げます:

\begin{itemize}
\item ハードリンクの作成でエラーが起こったり, 
      特別なセキュア カーネル (securelinux/openwall/grsecurity) を使っているときは, 
      Mailman のソース配布物のファイル
      \file{contrib/README.check_perms_grsecurity} を見てください. 

      Linux Mandrake をセキュア モードで使っているのなら, 
      これは役にたつでしょう. 

\item Mandrake は 9.0 あたりから gcc の実行権限を変更しています. 
      \code{mailman} ユーザになってビルドするのなら, 
      \code{mailman} が \code{cctools} グループにも所属しているようにします. 

\item Python を Linux ディストリビューションのパッケージ管理
      (例えば Redhat 系のシステムなら .rpm, Debian なら .deb)
      でインストールしたのなら, 
      Python ``開発用'' パッケージもインストールしなければいけません. 
      そうしないと期待したとおりの結果になりません. 

      例えば, Debian で Python 2.2 を使っているのなら, 
      \code{python2.2-dev} パッケージをインストールする必要があります. 
      Redhat では, たぶん \code{python2-devel} パッケージが必要でしょう. 

      Python をソースからインストールしたのなら, うまくいくはずです. 

      理屈はよくわかりませんが, インストールの最中につぎのようなエラーが起こるのなら, 
      この問題がおきていると判断してよいでしょう:

      \begin{verbatim}
          Traceback (most recent call last):
            File "bin/update", line 44, in ?
              import paths
          ImportError: No module named paths
          make: *** [update] Error 1
      \end{verbatim}

      これがおこるのなら, 
      Python の開発用パッケージをインストールしてから
      もう一度 \program{configure} と \program{make install} をやってみましょう. 
      あるいは, 最新バージョンの Python (\url{http://www.python.org}
      で入手できる) をソースからインストールします. 

      この問題は, 上記以外の Linux ディストリビューションでは
      違ったふうに表れるかもしれませんが, 
      普通は \code{ImportError} として表れます. 
\end{itemize}

\subsection{BSD について\label{bsd-issues}}

Vivek Khera によれば, 一部の BSD システムでは, 
夜間のセキュリティ スキャンで setuid ファイルの変更を調べます. 
setgid ディレクトリも, 変更されるとスキャン結果に現れます. 
また, BSD システムでは, ディレクトリの中にファイルを作ると, 
ディレクトリのグループ所有権を自動的に継承するので, 
setgid ビットはなくてもいいのです. 
他の \UNIX{} システムでは, ディレクトリの setgid ビットがオンになっていないと
こうはなりません. 

ディレクトリの setgid ビットをオンにせずにインストールするには, 
\program{configure} を実行したあとで, 
\program{make} に \var{DIRSETGID} 変数を渡せばいいです:

\begin{verbatim}
    % make DIRSETGID=: install
\end{verbatim}

これで, インストールされるディレクトリに対する
\program{chmod g+s} コマンドが無効になります. 

\subsection{MacOSX について}

Mailman を MacOSX で実行している人も大勢います. 
ここでは, Mailman を MacOSX で実行できるようにするために集めた
情報へのポインタを挙げておきます. 

\begin{itemize}
\item Jaguar (MacOSX 10.2) には Python 2.2 がついてきます. 
      が, これは Python のあまり最近の安定バージョンではなく, 
      Mailman 2.1 を実行するのには充分ではありません. 

\item David B. O'Donnell は, Web サイトで, 
      自分の MacOSX 上の Mailman 2.0.13 と Postfix の設定を説明しています. 

      \url{http://www.afp548.com/Articles/mail/python-mailman.html}

\item Kathleen Webb は, Jaguar で Sendmail を使って Mailman を実行できるように
      した経験を投稿してくれました. 

      \url{http://mail.python.org/pipermail/mailman-users/2002-October/022944.html}

\item Panther サーバ (MacOSX 10.3) には Mailman が入っています;
      オペレーティング システムには助けになる文書が含まれていますし,
      Apple は, Mailman を MacOSX Server 10.3 で動作させる際にぶつかりそうな
      問題についての技術文書を出しています:

      \url{http://docs.info.apple.com/article.html?artnum=107889}
\end{itemize}

Terry Allen は, 「クライアント」版の OSX や初期の版の OSX での Mailman
の実行について, 以下のような詳細な説明を提供してくれました
\hbox{\hfil ---\hss ---\hfil}

Mac OSX の 10.3 以降では, Mailman ははじめからインストールしてあります.
Mac OSX のそれ以前の版では
[訳注: MTA として Postfix ではなく] Sendmail が入っているので,
そういうユーザは, このマニュアルの Sendmail でのインストールの節を見て,
こつをつかんでください. このマニュアルの前のほうで説明している基本的なインストール手順を,
本節で概説している手順で適当に読み換えながら, 実施します.

Mac OSX 10.3 の「クライアント」版には, 既定ではフル機能版の Postfix が入っていません.
Postfix などの MTA を動作させる設定の説明はこの文書の範囲を超えますから,
\url{http://www.postfix.org} を見て,
Postfix が実行できるようにするこつをつかんでください.
Postfix をインストールして動作するように設定する簡単な方法としては,
Postfix Enabler を実行するというものがあります.
Mac OSX で Postfix を設定するためのスタンドアロンのツールです.
\url{http://www.roadstead.com/weblog/Tutorials/PostfixEnabler.html}
にあります.

また, Mac OSX 「クライアント」版でも 10.1 以降なら,
Apache ウェブサーバが動作するようになっています.
「システム管理設定」を使って「共有」タブの中で有効にします.
Webmin というツールは, Mac OSX で Apache を設定するのに役立ちます.
\url{http://www.webmin.com} で手に入ります.

Webmin では, システムのほかの機能についての設定もできます.
Postfix の設定, crontab へのジョブの追加, ユーザやグループの追加, などができます.
また, スタートアップジョブやシャットダウンジョブの追加もできます.

OSX の標準的なインストレーションでの Mailman の要求事項として,
Python がインストールされていること, というものがありますが,
Python は既定ではインストールされていません.
そこで, 開発ツール パッケージをインストールすることをお勧めします.
このパッケージは, システムとともに提供されているかもしれません.
また, Apple Developer Connection サイト % Apple developer site ???
\url{http://connect.apple.com} からダウンロードすることもできます.
開発ツール パッケージは,
Mailman をインストールするのにどうしても必要というわけではないのですが,
いつか他のツールが必要になったときにも役立ちそうなものではあります.
開発ツールは XCode Tools ともいいます.

Python のバージョンは, 最低限, 2.2 でなければなりません. しかし, 2.3 をお勧めします.

Webmin などの GUI インタフェースではなく,
OSX のコマンドラインを使ってユーザやグループを追加したければ,
ターミナル アプリケーションを開き, 以下に示すコマンドを入力します
(\samp{\#} ではじまるコメント行は, 単なる説明なので, 入力しません):

\begin{verbatim}
sudo tcsh
niutil -create / /users/mailman
niutil -createprop / /users/mailman name mailman
# xxx は, システム上で空いているユーザ ID 番号であることに注意
niutil -createprop / /users/mailman uid xxx
niutil -createprop / /users/mailman home /usr/local/mailman
mkdir -p /usr/local/mailman
niutil -createprop / /users/mailman shell /bin/tcsh
passwd mailman
# ここでは, 悪意のあるハッキングを防ぐため, セキュアなパスワードを与えること
niutil -create / /groups/mailman
niutil -createprop / /groups/mailman name mailman
# xxx は, システム上で空いているグループ ID 番号であることに注意
niutil -createprop / /groups/mailman gid xxx
niutil -createprop / /groups/mailman passwd '*'
niutil -createprop / /groups/mailman users 'mailman'
chown mailman:mailman /usr/local/mailman
cd /usr/local/mailman
chmod a+rx,g+ws .
exit
su mailman
\end{verbatim}

OSX の Apache で Mailman が使えるように設定する手順は,
[訳注: このマニュアルで説明しているのと] ほとんど同じです.
Mac OSX クライアント版の標準的な設定ファイルは
\file{/etc/httpd/httpd.conf} (これが標準の場所) あたりに格納されています.

\ulink{AFP548.com}{http://www.afp548.com} のサイトには,
スタートアップアイテムの自動作成ツールがあり, これを使うと手間が省けます.
\url{http://www.afp548.com/Software/MailmanStartup.tar.gz}
で見つかります.

インストールするには, このファイルを
\file{/Library/StartupItems} ディレクトリにコピーします.
ターミナルで root かスーパユーザになって, 次のものを入力します:

\begin{verbatim}
gunzip MailmanStartup.tar.gz
tar xvf MailmanStartup.tar
\end{verbatim}

これでスタートアップアイテムが作成されるので,
再起動すれば Mailman が開始されます.

\end{document}
